<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>학교생활기록부 성적 정규화 도구 (브라우저 버전)</title>
  <style>
    :root { --bg:#0b1020; --card:#121831; --muted:#9fb3ff; --text:#eaf0ff; --accent:#7da6ff; }
    html,body{height:100%;}
    body{margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,Apple Color Emoji; background:linear-gradient(180deg,#0b1020,#0a0f1d); color:var(--text);} 
    .wrap{max-width:1100px;margin:32px auto;padding:0 16px 48px;}
    .card{background:var(--card); border:1px solid #1a244a; border-radius:16px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{font-size:22px;margin:0 0 12px;}
    .muted{color:var(--muted); font-size:14px;}
    .controls{display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:16px}
    .controls .full{grid-column:1/-1}
    label{font-size:13px; color:#bfcbff; display:block; margin:6px 0}
    input,select,button{background:#0c1330; color:var(--text); border:1px solid #25326a; border-radius:10px; padding:10px 12px; font-size:14px; width:100%}
    input[type="file"]{padding:8px;}
    button{cursor:pointer; border:1px solid #3550b9; background:linear-gradient(180deg,#2441a7,#1b2d7a); font-weight:600}
    button.secondary{background:#0c1330; border-color:#2a3f96}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .row > *{flex:1}
    table{border-collapse:collapse; width:100%; font-size:13px}
    th,td{border-bottom:1px solid #24316a; padding:6px 8px; text-align:left;}
    thead th{position:sticky; top:0; background:#0f1840; z-index:1}
    .scroll{max-height:420px; overflow:auto; border:1px solid #1a244a; border-radius:12px}
    .pill{display:inline-block; padding:4px 8px; border:1px solid #2a3f96; border-radius:999px; font-size:12px; color:#caddff}
    .footer{margin-top:12px; font-size:12px; color:#b8c6ff}
    .hint{font-size:12px; color:#b8c6ff}
    .ok{color:#a3ffb0}
    .warn{color:#ffd29a}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>학교생활기록부 성적 정규화 도구 <span class="pill">브라우저</span></h1>
      <div class="muted">엑셀(XLSX/CSV)을 업로드하면, A–D열 공란을 위 행 값으로 채우고, 중간 헤더·요약 행을 제거하여 DB에 넣기 좋은 CSV로 변환합니다.</div>

      <div class="controls">
        <div class="full">
          <label>교과학습발달상황(Xlsx DATA양식) 업로드</label>
          <input id="file" type="file" accept=".xlsx,.xls,.csv" />
        </div>
        <div class="full">
          <label>학생편성현황 업로드</label>
          <input id="fileClasslist" type="file" accept=".xlsx,.xls,.csv" />
          <div class="hint">2행까지는 헤더이며 3행부터 데이터입니다.</div>
        </div>
        <div class="full">
          <label>교육과정 DB 업로드</label>
          <input id="fileCurriculum" type="file" accept=".xlsx,.xls" />
          <div class="hint">예: 교육과정편제표_2025년입학.xlsx (과목명/학점/교과/학년·학기 포함)</div>
        </div>
        <div class="full">
          <label>학생 과목선택 업로드</label>
          <input id="fileFutureSel" type="file" accept=".xlsx,.xls" />
          <div class="hint">예: 2025입학생_수강신청일괄등록20250922.xlsx (값=1은 선택)</div>
        </div>
        
        
        <div class="full row">
          <button id="btnClean">정리해서 미리보기</button>
          <button id="btnShowReport" class="secondary">리포트 보기</button>
          <button id="btnDownloadXlsx" class="secondary">XLSX 다운로드</button>
        </div>
        
      </div>

      <div id="status" class="footer" style="margin-top:16px"></div>

      <div id="preview" class="scroll" style="margin-top:16px; display:none"></div>
      <div id="report" class="scroll" style="margin-top:16px; display:none"></div>
    </div>
  </div>

<script>
// -------------- 유틸 --------------
const strip = (s) => (typeof s === 'string' ? s.replace(/\s+/g,'') : s);
function normalizeKeys(row){ const out={}; for(const k in row){ out[strip(k)] = row[k]; } return out; }
function toNum(v){
  if (v == null) return null;
  const s = typeof v === 'string' ? v.trim() : v;
  if (s === '') return null;
  const n = Number(s);
  return Number.isNaN(n) ? null : n;
}
function parseScoreAvg(v){
  if (v == null || v === '') return { 원점수:null, 과목평균:null };
  const s = String(v).trim();
  if (s.includes('/')){ const [L,R] = s.split('/',2); return { 원점수: toNum(L), 과목평균: toNum(R) }; }
  return { 원점수: toNum(s), 과목평균: null };
}
function parseDistribution(dist){
  const res = { A_pct:null, B_pct:null, C_pct:null, D_pct:null, E_pct:null };
  if (dist == null || dist === '') return res;
  const re = /([A-E])\s*\(\s*([\d.]+)\s*\)/g; let m; const s = String(dist);
  while((m=re.exec(s))){ const g=m[1]; const v = Number(m[2]); if(!Number.isNaN(v)) res[g+"_pct"] = v; }
  return res;
}
// 학년/반 텍스트 파서: 다양한 표기를 허용
function parseClassText(text){
  if (!text) return { year:null, klass:null };
  let s = String(text).replace(/\u00A0/g,' ').trim();
  // 전각 숫자 -> 반각
  const fw = '０１２３４５６７８９'; const hw='0123456789';
  s = s.replace(/[０-９]/g, ch => hw[fw.indexOf(ch)]);
  // 한글 숫자(단자리) -> 아라비아
  const map = { '일':'1','이':'2','삼':'3','사':'4','오':'5','육':'6','칠':'7','팔':'8','구':'9' };
  s = s.replace(/([일이삼사오육칠팔구])\s*(학\s*년|반)/g, (_,d,unit) => map[d] + unit.replace(/\s+/g,''));
  // 1) 명시적 패턴: 1학년 2반
  let m = s.match(/(\d+)\s*학\s*년[^\d]*?(\d+)\s*반/i);
  if (m) return { year: Number(m[1]), klass: Number(m[2]) };
  // 2) 각각 따로 존재
  let y = s.match(/(\d+)\s*학\s*년/i); let k = s.match(/(\d+)\s*반/i);
  if (y || k) return { year: y?Number(y[1]):null, klass: k?Number(k[1]):null };
  // 3) 하이픈/슬래시: 1-2, 1/2
  m = s.match(/(\d+)\s*[-~\/\.]\s*(\d+)/);
  if (m) return { year:Number(m[1]), klass:Number(m[2]) };
  // 4) 숫자 두 개 추출
  const nums = (s.match(/\d+/g) || []).map(n=>Number(n));
  if (nums.length >= 2) return { year:nums[0], klass:nums[1] };
  return { year:null, klass:null };
}
function isHeaderLike(row){
  const vals = Object.values(row).map(v => v==null?"":String(v));
  const first = vals[0]||'';
  return first.includes('번 호') || vals.includes('성 명') || vals.includes('학 년') || vals.includes('학 기');
}
function isSummaryOrPageRow(row){
  const vals = Object.values(row).map(v => v==null?"":String(v));
  const first = vals[0];
  const subj = row['과목'] || row['과목명'] || row['과목코드'];
  if (/이수학점/.test(first)) return true; // 이수학점 합계
  if (/^\s*\d+\s*\/\s*\d+\s*$/.test(first) && Object.keys(row).length <= 3) return true; // 페이지 표기
  if ((first === '' || first === 'None') && (!subj || String(subj).trim()==='')) return true; // 빈 행
  return false;
}

function cleanGradebook(rows, classInfo){
  // 1) 키 정규화
  let data = rows.map(normalizeKeys);
  // 2) 헤더/요약/페이지 행 제거
  data = data.filter(r => !isHeaderLike(r) && !isSummaryOrPageRow(r));
  // 3) forward-fill: 번호, 성명, 학년, 학기, 반
  const idKeys = ['번호','성명','학년','학기','반'];
  const last = { 번호:null, 성명:null, 학년:null, 학기:null, 반:null };
  data = data.map(r => { for(const k of idKeys){ if(r[k]==null || r[k]===''){ r[k]=last[k]; } else { last[k]=r[k]; } } return r; });
  // 4) 숫자형 변환
  ['번호','학년','반','학기','학점','학점수','석차등급','수강자수'].forEach(k => data.forEach(r => { if (k in r) r[k] = toNum(r[k]); }));
  // 5) 교과 키 통일 (기본 컬럼만 사용하도록 최소화)
  data.forEach(r => { if (r['교과']==null && r['교과명']!=null) r['교과']=r['교과명']; if (r['교과']==null && r['교과군']!=null) r['교과']=r['교과군']; });
  // 6) 학년/반 추출: A3 셀(classInfo)만 사용 (강화된 파서)
  let { year:fallbackYear, klass:fallbackClass } = parseClassText(classInfo);
  if (classInfo){
    // 메타 보존
    const {year:담당학년, klass:담당반} = parseClassText(classInfo);
    data.forEach(r=>{ r['담당학년']=담당학년 ?? null; r['담당반']=담당반 ?? null; r['반표기']=classInfo; });
  }
  // 데이터에 학년/반 없으면 보강
  data.forEach(r => {
    if ((r['학년']==null || r['학년']==='') && fallbackYear!=null) r['학년'] = fallbackYear;
    if ((r['반']==null || r['반']==='' || r['반']===0)){
      if (r['담당반']!=null) r['반'] = r['담당반'];
      else if (fallbackClass!=null) r['반'] = fallbackClass;
    }
  });
  // 이름 컬럼 보강: 성명 -> 이름 매핑
  data.forEach(r => { if (r['이름']==null && r['성명']!=null) r['이름'] = r['성명']; });
  // 7) 과목 없는 행 제거
  data = data.filter(r => { const subj = r['과목'] ?? r['과 목']; return subj!=null && String(subj).trim()!==''; });
  // 8) 최소 필요 컬럼만 출력 (요구사항):
  //    현재학년/현재반: A3에서 추출, 번호: A열(번호), 이름: B열(성명/이름),
  //    과목학년: C열(학년), 과목학기: D열(학기), 교과: E열(교과), 과목명: F열(과목), 학점: G열(학점)
  const makeRow = (r) => ({
    학년: fallbackYear ?? null,
    반: fallbackClass ?? null,
    번호: r['번호'] ?? null,
    이름: r['이름'] ?? r['성명'] ?? null,
    과목학년: r['학년'] ?? null,
    과목학기: r['학기'] ?? null,
    교과: r['교과'] ?? null,
    과목명: r['과목'] ?? null,
    학점: (r['학점'] ?? r['학점수'] ?? null),
  });
  const rowsOut = data.map(makeRow);
  const columns = ['학년','반','번호','이름','과목학년','과목학기','교과','과목명','학점'];
  return { columns, rows: rowsOut };
}

// -------------- 파일 로드 & 시트 처리 --------------
let _wb = null; let _cleaned = null; let _classText = null;
let _cleanedGB = null; // 교과학습발달상황 결과
let _cleanedCL = null; // 학생편성현황 결과
let _cleanedFP = null; // 미래 자료 결과
let _catalog = null;   // 교육과정 DB 카탈로그
const _nameIndex = new Map(); // key: G-C-N => 이름
let _report = { future: null };
const el = (id) => document.getElementById(id);

function getCurrentData(){
  const cols = ['학년','반','번호','이름','과목학년','과목학기','교과','과목명','학점'];
  let rows = [];
  if (_cleanedGB && Array.isArray(_cleanedGB.rows)) rows.push(..._cleanedGB.rows);
  if (_cleanedCL && Array.isArray(_cleanedCL.rows)) rows.push(..._cleanedCL.rows);
  if (_cleanedFP && Array.isArray(_cleanedFP.rows)) rows.push(..._cleanedFP.rows);
  if (rows.length) return { columns: cols, rows };
  if (_cleanedGB) return _cleanedGB;
  if (_cleanedCL) return _cleanedCL;
  return { columns: cols, rows: [] };
}

function showCurrentPreview(){
  const cur = getCurrentData();
  if (!cur.rows.length){ setStatus('<span class="warn">먼저 파일을 업로드/정리하세요.</span>'); return; }
  renderPreview(cur);
  const sources = [!!_cleanedGB, !!_cleanedCL, !!_cleanedFP].filter(Boolean).length;
  const src = sources>1 ? '통합' : (_cleanedGB ? '교과학습발달상황' : (_cleanedCL ? '학생편성현황' : '미래자료'));
  setStatus(`<span class="ok">${src} 미리보기</span> — 총 ${cur.rows.length}행 (미리보기 300행 고정)`);
}

// CDN 로드 실패시 사용자에게 안내
if (typeof window !== 'undefined' && typeof window.XLSX === 'undefined'){
  const s = document.getElementById('status');
  if (s) s.innerHTML = '<span class="warn">XLSX 라이브러리를 불러오지 못했습니다. (CDN) — 인터넷 연결을 확인하거나 로컬 사본으로 교체하세요.</span>';
}

function setWorkbookAndPopulateSheets(wb){
  _wb = wb;
  const sel = el('sheet');
  if (sel){
    sel.innerHTML='';
    _wb.SheetNames.forEach((name,i)=>{ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; if(i===0) opt.selected=true; sel.appendChild(opt); });
  }
}

function workbookFromCsvText(text){
  const aoa = XLSX.utils.sheet_to_json(XLSX.utils.csv_to_sheet(text), { header:1, defval:null });
  return { SheetNames: ['CSV'], Sheets: { 'CSV': XLSX.utils.aoa_to_sheet(aoa) } };
}

async function loadWorkbookFromBufferOrText(src, nameHint){
  const lower = (nameHint || '').toLowerCase();
  if (typeof src === 'string' || lower.endsWith('.csv')){
    const text = typeof src === 'string' ? src : new TextDecoder('utf-8').decode(new Uint8Array(src));
    return workbookFromCsvText(text);
  }
  return XLSX.read(src, { cellDates:false });
}

el('file').addEventListener('change', async (e) => {
  try{
    const f = e.target.files[0]; if (!f) return;
    setStatus('파일 읽는 중…');
    const buf = await f.arrayBuffer();
    const wb = await loadWorkbookFromBufferOrText(buf, f.name);
    setWorkbookAndPopulateSheets(wb);
    // 업로드 즉시 정리 및 미리보기 (자동 통합 반영)
    const rows = readRowsFromSelectedSheet();
    const classInfo = _classText || null;
    _cleanedGB = cleanGradebook(rows, classInfo);
    _cleaned = _cleanedGB;
    showCurrentPreview();
  }catch(err){
    console.error(err);
    setStatus(`<span class=\"warn\">파일 읽기 실패:</span> ${err?.message || err}`);
  }
});

 

function readRowsFromSelectedSheet(){
  const name = _wb.SheetNames[0];
  const ws = _wb.Sheets[name];
  // 상단 영역에서 학년/반 문자열 추출 (A3 우선, 이후 상단 스캔)
  function cellVal(c){ const v = ws[c]; return v ? (v.w ?? v.v) : null; }
  const preferred = ['A3','A2','B3','A1'];
  let cls = null;
  for(const addr of preferred){ const v = cellVal(addr); if (v!=null && /학|반/.test(String(v))) { cls = String(v); break; } }
  if (!cls){
    const cols = ['A','B','C','D','E'];
    outer: for(let r=1;r<=8;r++){
      for(const col of cols){ const addr = `${col}${r}`; const v = cellVal(addr); if (v==null) continue; const s = String(v); if (!/학|반/.test(s)) continue; const p = parseClassText(s); if (p.year!=null || p.klass!=null){ cls = s; break outer; } }
    }
  }
  _classText = cls;
  const aoa = XLSX.utils.sheet_to_json(ws, { header:1, defval:null });
  if (!aoa.length) return [];
  const stripS = (x) => x==null ? '' : String(x).replace(/\s+/g,'');
  const headerCandidates = ['번호','성명','학년','학기','과목','교과'];
  let headerIndex = 0; let maxHits = -1;
  const scanLimit = Math.min(20, aoa.length);
  for (let i=0; i<scanLimit; i++){
    const row = aoa[i] || [];
    let hits = 0;
    for (const cell of row){ const v = stripS(cell); if (headerCandidates.includes(v)) hits++; }
    if (hits > maxHits && hits >= 2){ headerIndex = i; maxHits = hits; }
  }
  const header = (aoa[headerIndex] || []).map(h => h==null?"":String(h));
  return aoa.slice(headerIndex+1).map(arr => { const obj={}; header.forEach((h,i)=> obj[h] = i < arr.length ? arr[i] : null); return obj; });
}

function setStatus(html){ el('status').innerHTML = html; }

function renderPreview(cleaned){
  const wrap = el('preview');
  el('report').style.display = 'none';
  const limit = 300;
  const cols = cleaned.columns; const rows = cleaned.rows.slice(0, limit);
  const thead = `<thead><tr>${cols.map(c=>`<th>${c}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r=>`<tr>${cols.map(c=>`<td>${r[c] ?? ''}</td>`).join('')}</tr>`).join('')}</tbody>`;
  wrap.innerHTML = `<table>${thead}${tbody}</table>`;
  wrap.style.display = 'block';
}

function renderReport(){
  const rep = _report.future;
  const box = el('report');
  const wrap = el('preview');
  if (!rep){ box.innerHTML = '<div class="hint">리포트가 없습니다. 미래 자료를 먼저 업로드하세요.</div>'; box.style.display='block'; wrap.style.display='none'; return; }
  const rows = [];
  rows.push(`<div class="footer">생성행: ${rep.produced||0} / 미매칭과목(카탈로그없음): ${Object.keys(rep.notInCatalog||{}).length} / 미래개설없음: ${Object.keys(rep.noFutureOffering||{}).length} / 학번없음: ${rep.skippedNoId||0}</div>`);
  function topList(obj, title){
    const entries = Object.entries(obj||{}).sort((a,b)=>b[1]-a[1]).slice(0,20);
    if (!entries.length) return `<div class="hint">${title}: 없음</div>`;
    const lis = entries.map(([k,v])=>`<tr><td>${k}</td><td style="text-align:right">${v}</td></tr>`).join('');
    return `<div style="margin-top:8px"><div class="muted">${title} (상위 20)</div><table><thead><tr><th>과목명</th><th>건수</th></tr></thead><tbody>${lis}</tbody></table></div>`;
  }
  rows.push(topList(rep.notInCatalog, 'DB에 과목명이 없음'));
  rows.push(topList(rep.noFutureOffering, '미래 개설이 없음'));
  box.innerHTML = rows.join('');
  box.style.display = 'block';
  wrap.style.display = 'none';
}

function downloadBlob(filename, blob){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; a.click(); URL.revokeObjectURL(a.href); }

function toCsv(rows){
  const ws = XLSX.utils.json_to_sheet(rows);
  const csv = XLSX.utils.sheet_to_csv(ws);
  return new Blob([csv], { type: 'text/csv;charset=utf-8;' });
}

function toXlsx(rows, sheetName='cleaned'){
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.json_to_sheet(rows);
  XLSX.utils.book_append_sheet(wb, ws, sheetName);
  const out = XLSX.write(wb, { bookType:'xlsx', type:'array' });
  return new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
}

function sortByGradeClassNumber(rows){
  const val = (x) => (x==null ? null : x);
  const cmp = (a,b) => {
    const va = val(a), vb = val(b);
    if (va==null && vb==null) return 0;
    if (va==null) return 1; // nulls last
    if (vb==null) return -1;
    const na = typeof va === 'number' ? va : Number(va);
    const nb = typeof vb === 'number' ? vb : Number(vb);
    if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
    return String(va).localeCompare(String(vb));
  };
  return [...rows].sort((r1,r2) => (
    cmp(r1['학년'], r2['학년']) ||
    cmp(r1['반'], r2['반']) ||
    cmp(r1['번호'], r2['번호'])
  ));
}

// ---------- 이름 인덱스 및 공통 유틸 ----------
function keyForName(g, c, n){ if (g==null||c==null||n==null) return null; return `${g}-${c}-${n}`; }
function updateNameIndexFrom(cleaned){
  if (!cleaned || !cleaned.rows) return;
  for (const r of cleaned.rows){
    const g = toNum(r['학년']); const c = toNum(r['반']); const n = toNum(r['번호']);
    const nm = r['이름'] ?? r['성명'] ?? null;
    const k = keyForName(g,c,n);
    if (k && nm && !_nameIndex.has(k)) _nameIndex.set(k, String(nm));
  }
}
function resolveName(g,c,n){ const k = keyForName(g,c,n); return k?(_nameIndex.get(k)??null):null; }

// ---------- 교육과정 DB ----------
function parseYearTermFromText(txt){ if (!txt) return { y:null, t:null }; const s=String(txt); const ym=s.match(/(\d+)\s*학년/); const tm=s.match(/(\d+)\s*학기/); return { y: ym?Number(ym[1]):null, t: tm?Number(tm[1]):null } }
function buildCurriculumCatalog(wb){
  const name = wb.SheetNames[0]; const ws = wb.Sheets[name];
  const aoa = XLSX.utils.sheet_to_json(ws, { header:1, defval:null });
  if (!aoa.length) return {};
  const header = (aoa[0]||[]).map(v=>v==null?'':String(v).trim());
  const idx = (label) => header.findIndex(h=>h.replace(/\s+/g,'')===label);
  const ixSem = idx('학기'); const ixSub = idx('과목명'); const ixCred = idx('학점'); const ixGroup = idx('교과군');
  const cat = {};
  for (let r=1; r<aoa.length; r++){
    const row = aoa[r]||[];
    const sem = ixSem>=0 ? row[ixSem] : null;
    const {y:subYear, t:subTerm} = parseYearTermFromText(sem);
    const subName = ixSub>=0 ? (row[ixSub]!=null?String(row[ixSub]).trim():null) : null;
    const credit = ixCred>=0 ? toNum(row[ixCred]) : null;
    const group = ixGroup>=0 ? (row[ixGroup]!=null?String(row[ixGroup]).trim():null) : null;
    if (!subName) continue;
    const rec = { 과목명: subName, 교과: group, 학점: credit, 과목학년: subYear, 과목학기: subTerm };
    if (!cat[subName]) cat[subName] = [];
    cat[subName].push(rec);
  }
  return cat;
}

// ---------- 학생 과목선택 ----------
function isCodeLike(s){ if(!s) return false; const t=String(s).trim(); return /^(?:\d{1,4}[A-Z]|[A-Z0-9]{6,})$/.test(t) || /^\d{6,}$/.test(t); }
function isCourseTitleLike(s){ if(!s) return false; const t=String(s).trim(); if (t==='' ) return false; if (/^[A-Z]$/.test(t)) return false; if (/^\d-\d$/.test(t)) return false; if (isCodeLike(t)) return false; return /[가-힣]/.test(t) || t.length>=2; }
function findCourseColumns(aoa){
  const headerRows = Math.min(4, aoa.length);
  const cols = new Map();
  for (let c=3; c< Math.max(...aoa.slice(0,headerRows).map(r=>r?.length||0))+5; c++){
    let best=null; let bestLen=0; let seen=false;
    for (let r=1; r<headerRows; r++){
      const v = aoa[r]?.[c]; if (v==null) continue; seen=true; const s=String(v).trim();
      if (isCourseTitleLike(s) && s.length>bestLen){ best=s; bestLen=s.length; }
    }
    if (seen && best){ cols.set(c, best); }
  }
  return cols;
}
function parseStudentId(id){ if (id==null) return null; const s=String(id).trim(); if (!/^\d{5}$/.test(s)) return null; const g=Number(s[0]); const c=Number(s.slice(1,3)); const n=Number(s.slice(3,5)); return {g,c,n}; }
function buildFutureRowsFromSelections(wb){
  if (!_catalog){ return { rows: [], stats: { noCatalog:true } }; }
  const name = wb.SheetNames[0]; const ws = wb.Sheets[name];
  const aoa = XLSX.utils.sheet_to_json(ws, { header:1, defval:null });
  if (!aoa.length) return { rows:[], stats:{} };
  const courseCols = findCourseColumns(aoa);
  let start = 0;
  for (let r=0; r<aoa.length; r++){
    const arr = aoa[r]||[]; const a=arr[0], b=arr[1], c=arr[2];
    const hasId = (/^\d{5}$/.test(String(a||'')) || /^\d{5}$/.test(String(b||'')) || /^\d{5}$/.test(String(c||'')) || String(a)==='0' || String(b)==='0' || String(c)==='0');
    if (hasId){ start = r; break; }
  }
  const out=[]; let skippedNoId=0, skippedNoCourse=0, produced=0;
  const notInCatalog = new Map();
  const noFutureOffering = new Map();
  for (let r=start; r<aoa.length; r++){
    const arr = aoa[r]||[];
    const id3 = parseStudentId(arr[2]); const id2 = parseStudentId(arr[1]); const id1 = parseStudentId(arr[0]);
    const cur = id3 || id2 || id1; if (!cur){ skippedNoId++; continue; }
    const {g,c,n} = cur;
    const 이름 = resolveName(g,c,n);
    for (const [ci, subName] of courseCols){
      const v = arr[ci]; if (!(v===1 || v==='1')) continue;
      const list = _catalog[subName];
      if (!list){
        skippedNoCourse++;
        notInCatalog.set(subName, (notInCatalog.get(subName)||0)+1);
        continue;
      }
      const offerings = list.filter(o => o.과목학년==null ? false : o.과목학년 >= g);
      if (!offerings.length){
        skippedNoCourse++;
        noFutureOffering.set(subName, (noFutureOffering.get(subName)||0)+1);
        continue;
      }
      for (const o of offerings){
        out.push({ 학년:g, 반:c, 번호:n, 이름:이름 ?? null, 과목학년:o.과목학년 ?? null, 과목학기:o.과목학기 ?? null, 교과:o.교과 ?? null, 과목명: subName, 학점: o.학점 ?? null }); produced++;
      }
    }
  }
  return { rows: out, stats: { skippedNoId, skippedNoCourse, produced, notInCatalog: Object.fromEntries(notInCatalog), noFutureOffering: Object.fromEntries(noFutureOffering) } };
}

// -------------- 이벤트 --------------
el('btnClean').addEventListener('click', () => {
  if (!_wb){ setStatus('<span class="warn">먼저 파일을 선택하세요.</span>'); return; }
  const rows = readRowsFromSelectedSheet();
  const classInfo = _classText || null;
  _cleanedGB = cleanGradebook(rows, classInfo);
  _cleaned = _cleanedGB;
  showCurrentPreview();
});



el('btnDownloadXlsx').addEventListener('click', () => {
  const cur = getCurrentData();
  if (!cur.rows.length){ setStatus('<span class="warn">먼저 파일을 업로드/정리하세요.</span>'); return; }
  const sorted = sortByGradeClassNumber(cur.rows);
  const blob = toXlsx(sorted);
  downloadBlob('정리완료.xlsx', blob);
});

el('btnShowReport').addEventListener('click', () => {
  renderReport();
  setStatus('<span class="ok">리포트 표시</span> — 상단에 요약/상위 항목이 보입니다');
});

// -------------- 교육과정 DB 이벤트 --------------
el('fileCurriculum').addEventListener('change', async (e) => {
  try{
    const f = e.target.files[0]; if(!f) return; setStatus('교육과정 DB 읽는 중…');
    const buf = await f.arrayBuffer(); const wb = await loadWorkbookFromBufferOrText(buf, f.name);
    _catalog = buildCurriculumCatalog(wb);
    setStatus(`<span class=\"ok\">교육과정 DB 로드</span> — 과목 ${Object.keys(_catalog).length}개`);
    showCurrentPreview();
  }catch(err){ console.error(err); setStatus(`<span class=\"warn\">교육과정 DB 실패:</span> ${err?.message||err}`); }
});

// -------------- 학생 과목선택 이벤트 --------------
el('fileFutureSel').addEventListener('change', async (e) => {
  try{
    const f = e.target.files[0]; if(!f) return; setStatus('학생 과목선택 읽는 중…');
    const buf = await f.arrayBuffer(); const wb = await loadWorkbookFromBufferOrText(buf, f.name);
    const { rows, stats } = buildFutureRowsFromSelections(wb);
    _cleanedFP = { columns: ['학년','반','번호','이름','과목학년','과목학기','교과','과목명','학점'], rows };
    _report.future = stats;
    _cleaned = _cleanedFP;
    showCurrentPreview();
    setStatus(`<span class=\"ok\">미래 자료 생성</span> — ${rows.length}행 (미리보기 300행 고정), 미매칭 ${stats.skippedNoCourse||0}건`);
  }catch(err){ console.error(err); setStatus(`<span class=\"warn\">학생 과목선택 실패:</span> ${err?.message||err}`); }
});

// -------------- 학생편성현황 파서 --------------
function extractFirstNumber(text){
  if (text == null) return null;
  const s = String(text);
  const m = s.match(/\d+(?:\.\d+)?/);
  return m ? Number(m[0]) : null;
}
function parseSubjectWithCredit(text){
  if (text == null) return { name: null, credit: null };
  const s = String(text).trim();
  // 마지막 괄호 안 숫자 추출
  const m = s.match(/^(.*?)[\(（]\s*([\d.]+)\s*[\)）]\s*$/);
  if (m){
    return { name: m[1].trim(), credit: Number(m[2]) };
  }
  return { name: s, credit: null };
}

el('fileClasslist').addEventListener('change', async (e) => {
  try{
    const f = e.target.files[0]; if (!f) return;
    setStatus('학생편성현황 읽는 중…');
    const buf = await f.arrayBuffer();
    const wb = await loadWorkbookFromBufferOrText(buf, f.name);
    const name = wb.SheetNames[0];
    const ws = wb.Sheets[name];
    const aoa = XLSX.utils.sheet_to_json(ws, { header:1, defval:null });
    // 3행부터 데이터 (0-index 기준 2부터)
    const rows = aoa.slice(2);
    const outRows = [];
    for (const arr of rows){
      const subjTermRaw = arr[1]; // B: 과목학기
      const subjYearRaw = arr[2]; // C: 과목학년
      const subjectGroup = arr[3]; // D: 교과
      const subjectWithCredit = arr[4]; // E: 과목명(학점)
      const gradeText = arr[6]; // G: n학년
      const classText = arr[7]; // H: n반 (이외 패턴은 skip)
      const numberRaw = arr[8]; // I: 번호
      const nameRaw = arr[9]; // J: 이름

      // 반이 정확히 "n반" 형태가 아니면 스킵 (예: "심화수학1반(...)" 제외)
      if (!(typeof classText === 'string' || typeof classText === 'number')) continue;
      const classStr = String(classText).trim();
      const classMatch = classStr.match(/^(\d+)\s*반$/);
      if (!classMatch) continue;

      const gradeMatch = String(gradeText ?? '').match(/(\d+)/);
      const 학년 = gradeMatch ? Number(gradeMatch[1]) : null;
      const 반 = Number(classMatch[1]);
      const 번호 = toNum(numberRaw);
      const 이름 = nameRaw != null ? String(nameRaw).trim() : null;

      // 이름에 괄호 포함 시 (예: "(미재학)홍길동") 해당 행 무시
      if (이름 && /[()（）]/.test(이름)) continue;

      const 과목학기 = extractFirstNumber(subjTermRaw);
      const 과목학년 = extractFirstNumber(subjYearRaw);
      const 교과 = subjectGroup != null ? String(subjectGroup) : null;
      const { name: 과목명, credit: 학점 } = parseSubjectWithCredit(subjectWithCredit);

      // 최소 유효성: 이름/번호/과목명 중 하나라도 충분히 있어야 함
      if (이름==null && 번호==null && 과목명==null) continue;

      outRows.push({ 학년, 반, 번호, 이름, 과목학년, 과목학기, 교과, 과목명, 학점 });
    }
    _cleanedCL = { columns: ['학년','반','번호','이름','과목학년','과목학기','교과','과목명','학점'], rows: outRows };
    _cleaned = _cleanedCL;
    try{ updateNameIndexFrom(_cleanedCL); }catch(_){ }
    showCurrentPreview();
  }catch(err){
    console.error(err);
    setStatus(`<span class=\"warn\">학생편성현황 읽기 실패:</span> ${err?.message || err}`);
  }
});

// (통합 전용 버튼 제거) 두 파일이 있으면 자동 통합하여 미리보기/다운로드에 반영합니다.

</script>
</body>
</html>
